[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generation.Generate

open FSharpWrap.Tool
open FSharpWrap.Tool.Reflection

let private moduleAttr =
    let attrType =
        { Name = FsName "CompilationRepresentationAttribute"
          Namespace = Namespace.ofStr "Microsoft.FSharp.Core"
          Parent = None
          TypeArgs = TypeArgList.empty }
    { Arguments = [ "global.Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix" ]
      AttributeType = attrType }

let binding parent mber =
    let name = Print.memberName mber |> FsName
    match mber with
    | InstanceMethod mthd ->
        let mparams =
            mthd.Params
            |> ParamList.ofList
            |> ParamList.append
                { ArgType = TypeName parent.TypeName |> TypeArg
                  IsOptional = RequiredParam
                  ParamName = FsName "this" }
        let targs =
            match mthd.TypeArgs with
            | TypeArgs(_ :: _ as targs) ->
                List.map
                    Print.typeArg
                    targs
                |> String.concat ","
                |> sprintf "<%s>"
            | _ -> ""
        let rest, this =
            let rec inner rest =
                function
                | [] -> invalidOp "The parameter list was unexpectedly empty"
                | [ this ] -> List.rev rest, this
                | h :: tail -> inner (h :: rest) tail
            mparams
            |> ParamList.toList
            |> inner []
        {| Body =
            sprintf
                "%s.``%s``%s(%s)"
                (Print.fsname this.ParamName)
                mthd.MethodName
                targs
                (Print.arguments rest)
           Name = name
           Parameters =
             mparams
             |> ParamList.toList
             |> List.map
                (fun param -> param.ParamName, param.ArgType)  |}
        |> GenFunction
        |> Some
    | _ -> None

let fromType (t: TypeDef): GenModule =
    { Attributes = List.singleton moduleAttr
      Bindings =
        List.fold
            (fun bindings mber ->
                match binding t mber with
                | Some gen when Set.contains gen bindings |> not ->
                    Set.add gen bindings
                | _ -> bindings)
            Set.empty
            t.Members
      ModuleName = t.TypeName.Name }

let private addType (mdles, dups) tdef =
    let { Name = name; Namespace = ns } = tdef.TypeName
    let types =
        mdles
        |> Map.tryFind ns
        |> Option.defaultValue Map.empty
    match Map.tryFind name types with
    | Some _ ->
        mdles, tdef :: dups
    | None ->
        let types' =
            Map.add
                name
                (fromType tdef)
                types
        let mdles' =
            Map.add
                ns
                types'
                mdles
        mdles', dups

let fromAssemblies (assms: seq<AssemblyInfo>) =
    let namespaces, dups =
        assms
        |> Seq.collect (fun assm -> assm.Types)
        |> Seq.fold
            addType
            (Map.empty, List.empty)
    { Header =
        seq {
            "This code was automatically generated by FSharpWrap"
            "Changes made to this file will be lost when it is regenerated"
            for assm in assms do
                sprintf "- %s" assm.FullName
            if not dups.IsEmpty then
                "Duplicate types found:"
                for dup in dups do
                    dup.TypeName
                    |> Print.typeName
                    |> sprintf "- %s"
        }
      Namespaces = namespaces }
