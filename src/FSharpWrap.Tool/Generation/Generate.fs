[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generation.Generate

open FSharpWrap.Tool
open FSharpWrap.Tool.Reflection

let private moduleAttr =
    let attrType =
        { Name = FsName "CompilationRepresentationAttribute"
          Namespace = Namespace.ofStr "Microsoft.FSharp.Core"
          Parent = None
          TypeArgs = TypeArgList.empty }
    { Arguments = [ "global.Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix" ]
      AttributeType = attrType }

let binding parent mber =
    let name = Print.memberName mber |> FsName
    match mber with
    | InstanceMethod mthd ->
        let mparams =
            mthd.Params
            |> ParamList.ofList
            |> ParamList.append
                { ArgType = TypeName parent.TypeName |> TypeArg
                  IsOptional = RequiredParam
                  ParamName = FsName "this" }
        let targs =
            match mthd.TypeArgs with
            | TypeArgs(_ :: _ as targs) ->
                List.map
                    Print.typeArg
                    targs
                |> String.concat ","
                |> sprintf "<%s>"
            | _ -> ""
        let rest, this =
            let rec inner rest =
                function
                | [] -> invalidOp "The parameter list was unexpectedly empty"
                | [ this ] -> List.rev rest, this
                | h :: tail -> inner (h :: rest) tail
            mparams
            |> ParamList.toList
            |> inner []
        {| Body =
            sprintf
                "%s.``%s``%s(%s)"
                (Print.fsname this.ParamName)
                mthd.MethodName
                targs
                (Print.arguments rest)
           Name = name
           Parameters =
             mparams
             |> ParamList.toList
             |> List.map
                (fun param -> param.ParamName, param.ArgType)  |}
        |> GenFunction
        |> Some
    | _ -> None

let fromType (t: TypeDef): GenModule =
    { Attributes = List.singleton moduleAttr
      Bindings =
        List.fold
            (fun bindings mber ->
                match binding t mber with
                | Some gen when Set.contains gen bindings |> not ->
                    Set.add gen bindings
                | _ -> bindings)
            Set.empty
            t.Members
      ModuleName = t.TypeName.Name }

let private addType mdles tdef =
    let { Name = name; Namespace = ns } = tdef.TypeName
    let types =
        mdles
        |> Map.tryFind ns
        |> Option.defaultValue Map.empty
    let mdle =
        let init = fromType tdef
        match Map.tryFind name types with
        | Some existing ->
            let bindings =
                 Set.union
                    existing.Bindings
                    init.Bindings
            { existing with Bindings = bindings }
        | None -> init
    match mdle.Bindings with
    | Empty -> mdles
    | _ ->
        let types' =
            Map.add
                name
                mdle
                types
        Map.add ns types' mdles

let fromAssemblies (assms: seq<AssemblyInfo>) =
    { Header =
        seq {
            "This code was automatically generated by FSharpWrap"
            "Changes made to this file will be lost when it is regenerated"
            for assm in assms do
                sprintf "- %s" assm.FullName
        }
      Namespaces =
        assms
        |> Seq.collect (fun assm -> assm.Types)
        |> Seq.fold
            addType
            Map.empty }
