[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generate

open System
open System.Collections.Generic
open System.IO
open System.Reflection

open FSharpWrap.Tool.Print

type private TypeIdentifier =
    | SingleType of Type
    | MultipleTypes of Map<uint32, Type>

let fromAssemblies (assemblies: seq<Assembly>) (filter: Filter) =
    print {
        let assemblies' =
            Seq.where
                (Filter.assemblyIncluded filter)
                assemblies
            |> Array.ofSeq
        "// This code was automatically generated by FSharpWrap"
        "// Changes made to this file will be lost when it is regenerated"
        "// # Included Assemblies:"
        for assembly in assemblies' do
            sprintf "// - %s" assembly.FullName
        let namespaces =
            let types =
                assemblies'
                |> Seq.collect (fun assembly -> assembly.ExportedTypes)
                |> Seq.where (Filter.typeIncluded filter)
            let dict = Dictionary<Namespace, Dictionary<TypeName, TypeIdentifier>> assemblies'.Length
            for t in types do
                let ns = Namespace.ofStr t.Namespace // TODO: Figure out how to cache namespaces.
                let name = TypeName.ofType t
                match dict.TryGetValue ns with
                | true, previous ->
                    match previous.TryGetValue name with
                    | (true, SingleType other) -> invalidOp "bad"
                    | (true, MultipleTypes others) ->
                        let gargs = t.GetGenericArguments().Length |> uint32
                        previous.Item <- name, Map.add gargs t others |> MultipleTypes
                    | (false, _) -> previous.Add(name, SingleType t)
                | false, _ ->
                    let entry = Dictionary 1
                    entry.Item <- name, SingleType t
                    dict.Item <- ns, entry
            dict
        for KeyValue(ns, types) in namespaces do
            Print.ns ns
            for t in types do
                ()
        // TODO: Figure out how code for a module is generated if the types have the same name but a different number of generic parameters.
    }

let fromResolver resolver loader =
    use context = new MetadataLoadContext(resolver)
    loader context |> fromAssemblies

let fromPaths assemblies =
    let files =
        Seq.collect
            (function
            | Directory dir ->
                Directory.EnumerateFiles(dir.Path, "*.dll", SearchOption.AllDirectories)
            | File file -> Seq.singleton file.Path)
            assemblies
    fromResolver
        (PathAssemblyResolver files)
        (fun context -> Seq.map context.LoadFromAssemblyPath files)
