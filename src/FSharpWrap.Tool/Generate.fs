[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generate

open System
open System.Collections.Generic
open System.IO
open System.Reflection

open FSharpWrap.Tool.Print

[<StructuralComparison; StructuralEquality>]
type private TypeName = // TODO: Should this be a struct?
    { Name: FsName
      Namespace: Namespace
      Parent: TypeName option }

type private TypeIdentifier =
    | SingleType of Type
    | MultipleTypes of Map<uint32, Type>

let rec private typeName (t: Type) =
    let parent = Option.ofObj t.DeclaringType
    { Name = FsName.ofType t
      Namespace = Namespace.ofStr t.Namespace
      Parent = Option.map typeName parent }

let fromAssemblies (assemblies: seq<Assembly>) (filter: Filter) (printer: Printer) =
    let assemblies' =
        Seq.where
            (Filter.assemblyIncluded filter)
            assemblies
        |> Array.ofSeq
    printer.WriteComment "This code was automatically generated by FSharpWrap"
    printer.WriteComment "Changes made to this file will be lost when it is regenerated"
    printer.WriteComment "# Included Assemblies:"
    for assembly in assemblies' do
        sprintf "- %s" assembly.FullName |> printer.WriteComment
    let namespaces =
        let types =
            assemblies'
            |> Seq.collect (fun assembly -> assembly.ExportedTypes)
            |> Seq.where (Filter.typeIncluded filter)
        let dict = Dictionary<Namespace, Dictionary<TypeName, TypeIdentifier>> assemblies'.Length
        for t in types do
            let ns = Namespace.ofStr t.Namespace // TODO: Figure out how to cache namespaces.
            let name = typeName t
            match dict.TryGetValue ns with
            | true, previous ->
                match previous.TryGetValue name with
                | (true, SingleType other) -> invalidOp "bad"
                | (true, MultipleTypes others) ->
                    let gargs = t.GetGenericArguments().Length |> uint32
                    previous.Item <- name, Map.add gargs t others |> MultipleTypes
                | (false, _) -> previous.Add(name, SingleType t)
            | false, _ ->
                let entry = Dictionary 1
                entry.Item <- name, SingleType t
                dict.Item <- ns, entry
        dict
    // TODO: Print namespaces.
    for KeyValue(ns, types) in namespaces do
        printer.WriteNamespace ns

    // TODO: Figure out how code for a module is generated if the types have the same name but a different number of generic parameters.
    ()

let fromResolver resolver loader =
    use context = new MetadataLoadContext(resolver)
    loader context |> fromAssemblies

let fromPaths assemblies =
    let files =
        Seq.collect
            (function
            | Directory dir ->
                Directory.EnumerateFiles(dir.Path, "*.dll", SearchOption.AllDirectories)
            | File file -> Seq.singleton file.Path)
            assemblies
    fromResolver
        (PathAssemblyResolver files)
        (fun context -> Seq.map context.LoadFromAssemblyPath files)
