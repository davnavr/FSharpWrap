[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generate

open System
open System.Collections.Generic
open System.IO
open System.Reflection

open FSharpWrap.Tool.Print

type private TypeIdentifier =
    | SingleType of Type
    | MultipleTypes of Map<uint32, Type>

let genericArgCount (t: Type) =
    t.GetGenericArguments() |> Array.length |> uint32

let fromAssemblies (assemblies: seq<Assembly>) (filter: Filter) =
    print {
        let assemblies' =
            Seq.where
                (Filter.assemblyIncluded filter)
                assemblies
            |> Array.ofSeq
        "// This code was automatically generated by FSharpWrap"; nl
        "// Changes made to this file will be lost when it is regenerated"; nl
        "// # Included Assemblies:"; nl
        for assembly in assemblies' do
            sprintf "// - %s" assembly.FullName; nl
        let namespaces =
            let types =
                assemblies'
                |> Seq.collect (fun assembly -> assembly.ExportedTypes)
                |> Seq.where
                    (fun t ->
                        not t.IsNested && Filter.typeIncluded filter t) // TODO: Include nested types inside nested modules.
            let dict = Dictionary<Namespace, Dictionary<TypeName, TypeIdentifier>> assemblies'.Length
            for t in types do
                let ns = Namespace.ofStr t.Namespace // TODO: Figure out how to cache namespaces.
                let name = TypeName.ofType t
                match dict.TryGetValue ns with
                | true, previous ->
                    let entry =
                        match previous.TryGetValue name with
                        | (true, SingleType other) ->
                            Map.empty
                            |> Map.add (genericArgCount other) other
                            |> Map.add (genericArgCount t) t
                            |> MultipleTypes
                        | (true, MultipleTypes others) ->
                            Map.add (genericArgCount t) t others |> MultipleTypes
                        | (false, _) -> SingleType t
                    previous.Item <- name, entry
                | false, _ ->
                    let entry = Dictionary 1
                    entry.Item <- name, SingleType t
                    dict.Item <- ns, entry
            dict
        for KeyValue(ns, types) in namespaces do
            "namespace "
            Print.ns ns
            nl
            indent
            for KeyValue(name, t) in types do
                match t with
                | SingleType t' ->
                    print {
                        ""
                    }
                    |> mdle name.Name
                | _ ->
                    // TODO: Figure out how code for a module is generated if the types have the same name but a different number of generic parameters.
                    "// Code generation for types with same name not yet implemented"
            dedent
            nl
    }

let fromResolver resolver loader filter printer =
    use context = new MetadataLoadContext(resolver)
    fromAssemblies (loader context) filter printer

let fromPaths assemblies =
    let files =
        Seq.collect
            (function
            | Directory dir ->
                Directory.EnumerateFiles(dir.Path, "*.dll", SearchOption.AllDirectories)
            | File file -> Seq.singleton file.Path)
            assemblies
    fromResolver
        (PathAssemblyResolver files)
        (fun context -> Seq.map context.LoadFromAssemblyPath files)
