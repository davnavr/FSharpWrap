[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generate

open FSharpWrap.Tool.Reflection

let indented lines = Seq.map (sprintf "    %s") lines
let block start stop lines =
    seq {
        yield start
        yield! indented lines
        yield stop
    }

let inline private attr name args =
    sprintf "[<%s(%s)>]" name args

let fromMembers mname members =
    [
        attr
            "global.Microsoft.FSharp.Core.CompilationRepresentation"
            "global.Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix"
        sprintf "module ``%s`` =" mname
        yield! block "begin" "end"
            [
                for (parent: TypeRef, mdef) in members do // TODO: How to handle method overloads?
                    // TODO: Add extra indentation when printing out members.

                    //let f =
                    //    Member.fsname mdef |> sprintf "let inline ``%s`` %s"
                    //match mdef with
                    //| InstanceMember inst ->
                    //    match inst with
                    //    | InstanceProperty iprop when iprop.Setter ->
                    //        sprintf
                    //            "(this: %s) = this.``%s``"
                    //            (TypeRef.fsname parent)
                    //            iprop.Name
                    //        |> f
                    //| UnknownMember name ->
                    sprintf
                        "// Unkown member %s in type %s"
                        (Member.fsname mdef)
                        parent.FullName
            ]
            |> indented
    ]

let fromNamespace (name: Namespace) types =
    [
        sprintf "namespace %O" name
        yield!
            types
            |> Set.fold
                (fun map (tdef: TypeDef) ->
                    let tset =
                        Map.tryFind tdef.Name map
                        |> Option.defaultValue Set.empty
                        |> Set.add tdef
                    Map.add tdef.Name tset map)
                Map.empty
            |> Map.toSeq
            |> Seq.collect (fun (mname, tdefs) ->
                Seq.collect
                    (fun { Info = info; Members = members } ->
                        Seq.map
                            (fun mdef -> info, mdef)
                            members)
                    tdefs
                |> fromMembers (string mname))
            |> indented
    ]

let fromAssemblies (assms: AssemblyInfo list) =
    let types, dups, dupcnt =
        assms
        |> Seq.collect (fun assm -> assm.Types)
        |> Seq.fold
            (fun (types', dups', dupcnt') tdef ->
                let tset =
                    Map.tryFind tdef.Namespace types'
                    |> Option.defaultValue Set.empty
                if Set.contains tdef tset
                then types', tdef :: dups', dupcnt' + 1
                else Map.add tdef.Namespace (Set.add tdef tset) types', dups', dupcnt')
            (Map.empty, [], 0)
    [
        "// This code was automatically generated by FSharpWrap"
        "// Changes made to this file will be lost when it is regenerated"
        "// Generated code for assemblies"
        for assm in assms do
            sprintf "// - %s" assm.FullName
        sprintf "// Found %i duplicate types" dupcnt
        for dup in dups do
            sprintf "// - %s" dup.FullName
        yield!
            types
            |> Map.toSeq
            |> Seq.collect (fun (ns, tdefs) -> fromNamespace ns tdefs)
    ]
