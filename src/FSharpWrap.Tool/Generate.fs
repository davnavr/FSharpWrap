[<RequireQualifiedAccess>]
module FSharpWrap.Tool.Generate

open System
open System.Collections.Generic
open System.IO
open System.Reflection

open FSharpWrap.Tool.Print

type TypeIdentifier =
    | SingleType of Type
    | MultipleTypes of Map<uint32, Type>

let genericArgCount (GenericArgs gargs) = Array.length gargs |> uint32

let memberName (mber: MemberInfo) =
    match mber with
    | Type t -> FsName.ofType t
    | Constructor ctor ->
        let parameters =
            ctor.GetParameters()
            |> List.ofArray
            |> List.map (fun t -> t.ParameterType)
        match parameters with
        // TODO: Match other patterns
        | _ -> FsName "create"
    | Event _
    | Field _
    | Method _
    | Property _ -> String.toCamelCase mber.Name |> FsName

let mdle name (t: Type) = // TODO: How to check for name conflicts for members contained in the module?
    let tname = Type.name t
    let members = t.GetMembers()
    let bindings = HashSet<FsName> members.Length
    let members' =
        members
        |> Seq.where (fun m -> m.DeclaringType = t)
        |> Seq.choose
            (function
            // TODO: Exclude property accessors.
            | :? EventInfo -> None
            | mber -> Some mber)

    print {
        for mber in members' do
            let name = memberName mber
            if bindings.Contains name then // TODO: How to prioritize certain method overloads?
                sprintf "// Duplicate member %s with generated name %O" mber.Name name
            else
                match mber with // TODO: How to ensure unique parameter names for constructors, methods, and properties with parameters
                | Constructor ctor ->
                    print {
                        Params.ofCtor ctor |> parameters
                        "= new "
                        //something tname
                        // TODO: Print the arguments.
                    }
                    |> binding name
                    sprintf "// TODO: Generate code for constructor calls."
                | Event e -> sprintf "// NOTE: Generation of members for event %s is not yet supported" e.Name
                | Field(Instance field) when field.IsInitOnly -> accessor name tname field.Name
                | Field field -> sprintf "// NOTE: Generation of member for mutable or static fields such as %s is not yet supported" field.Name
                | Method(Instance mthd) -> "// TODO: Generate code for instance methods."
                | Method(Static mthd) -> "// TODO: Generate code for static methods."
                // TODO: Check if property is instance property for these two checks.
                | Property (Indexer prop) -> sprintf "// NOTE: Generation of member for property with parameter %s is not yet supported" prop.Name
                | Property prop when prop.CanRead && not prop.CanWrite -> accessor name tname prop.Name
                | Property prop -> sprintf "// NOTE: Generation of member for property %s with setters not yet supported" prop.Name
                | Type t -> sprintf "// NOTE: Generation of nested module for nested type %s is not yet supported" t.Name
            nl

        // TODO: Create computation expression.
    }
    |> Print.mdle name t

let mdle1 = invalidOp "bad"

let fromAssemblies (assemblies: seq<Assembly>) (filter: Filter) =
    print {
        let assemblies' =
            Seq.where
                (Filter.assemblyIncluded filter)
                assemblies
            |> Array.ofSeq
        "// This code was automatically generated by FSharpWrap"; nl
        "// Changes made to this file will be lost when it is regenerated"; nl
        "// # Included Assemblies:"; nl
        for assembly in assemblies' do
            sprintf "// - %s" assembly.FullName; nl
        let namespaces =
            let types =
                assemblies'
                |> Seq.collect (fun assembly -> assembly.ExportedTypes)
                |> Seq.where
                    (fun t ->
                        not t.IsNested && Filter.typeIncluded filter t) // TODO: Include nested types inside nested modules.
            let dict = Dictionary<Namespace, Dictionary<TypeName, TypeIdentifier>> assemblies'.Length
            for t in types do
                let ns = Namespace.ofStr t.Namespace // TODO: Figure out how to cache namespaces.
                let name = Type.name t
                match dict.TryGetValue ns with
                | true, previous ->
                    let entry =
                        match previous.TryGetValue name with
                        | (true, SingleType other) ->
                            Map.empty
                            |> Map.add (genericArgCount other) other
                            |> Map.add (genericArgCount t) t
                            |> MultipleTypes
                        | (true, MultipleTypes others) ->
                            Map.add (genericArgCount t) t others |> MultipleTypes
                        | (false, _) -> SingleType t
                    previous.Item <- name, entry
                | false, _ ->
                    let entry = Dictionary 1
                    entry.Item <- name, SingleType t
                    dict.Item <- ns, entry
            dict
        for KeyValue(ns, types) in namespaces do
            "namespace "
            Print.ns ns
            nl
            indent
            for KeyValue({ Name = name }, t) in types do
                match t with
                | SingleType t' -> mdle name t'
                | MultipleTypes dups ->
                    for KeyValue(i, t') in dups do
                        let name' = FsName.append (sprintf "_%i" i) name
                        mdle1 name' t'
            dedent
            nl
    }

let fromResolver resolver loader filter printer =
    use context = new MetadataLoadContext(resolver)
    fromAssemblies (loader context) filter printer

let fromPaths assemblies =
    let files =
        Seq.collect
            (function
            | Directory dir ->
                Directory.EnumerateFiles(dir.Path, "*.dll", SearchOption.AllDirectories)
            | File file -> Seq.singleton file.Path)
            assemblies
    fromResolver
        (PathAssemblyResolver files)
        (fun context -> Seq.map context.LoadFromAssemblyPath files)
